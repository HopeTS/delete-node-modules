{"version":3,"sources":["../src/index.ts"],"sourcesContent":["#!/usr/bin/env node\nimport fs from \"fs\";\nimport path from \"path\";\nimport process from \"process\";\n\n/**\n * Recursively walk a directory and find all node_modules folders.\n *\n * @param rootDir Absolute path to search from.\n *\n * @return List of absolute paths to node_modules folders.\n */\nexport async function findNodeModulesDirs(rootDir: string): Promise<string[]> {\n  const results: string[] = [];\n\n  async function walk(current: string): Promise<void> {\n    let entries: fs.Dirent[];\n\n    try {\n      entries = await fs.promises.readdir(current, { withFileTypes: true });\n    } catch {\n      // Skip directories we can't read\n      return;\n    }\n\n    for (const entry of entries) {\n      if (!entry.isDirectory()) continue;\n\n      // Skip symlink directories\n      if (\n        typeof entry.isSymbolicLink === \"function\" &&\n        entry.isSymbolicLink()\n      ) {\n        continue;\n      }\n\n      const fullPath = path.join(current, entry.name);\n\n      if (entry.name === \"node_modules\") {\n        results.push(fullPath);\n        // Don't descend into node_modules; it's going to be deleted\n        continue;\n      }\n\n      await walk(fullPath);\n    }\n  }\n\n  await walk(rootDir);\n  return results;\n}\n\n/**\n * Delete a directory recursively (like rm -rf).\n */\nexport async function deleteDir(dir: string): Promise<void> {\n  await fs.promises.rm(dir, { recursive: true, force: true });\n}\n\nexport interface DeleteNodeModulesResult {\n  found: string[];\n  deleted: string[];\n}\n\n/**\n * Find and delete all node_modules under rootDir.\n */\nexport async function deleteNodeModules(\n  rootDir: string\n): Promise<DeleteNodeModulesResult> {\n  const absRoot = path.resolve(rootDir);\n  const found = await findNodeModulesDirs(absRoot);\n\n  const deleted: string[] = [];\n\n  for (const dir of found) {\n    try {\n      await deleteDir(dir);\n      console.log(\"Deleted dir\", dir);\n      deleted.push(dir);\n    } catch (err: any) {\n      console.error(`Failed to delete ${dir}:`, err?.message ?? err);\n    }\n  }\n\n  return { found, deleted };\n}\n\n(async function () {\n  const dirArg = process.argv[2] || process.cwd();\n  if (!fs.existsSync(dirArg)) {\n    console.log(\"Invalid path argument\");\n    return;\n  }\n  await deleteNodeModules(dirArg);\n})();\n"],"mappings":";;;AACA,OAAO,QAAQ;AACf,OAAO,UAAU;AACjB,OAAO,aAAa;AASpB,eAAsB,oBAAoB,SAAoC;AAC5E,QAAM,UAAoB,CAAC;AAE3B,iBAAe,KAAK,SAAgC;AAClD,QAAI;AAEJ,QAAI;AACF,gBAAU,MAAM,GAAG,SAAS,QAAQ,SAAS,EAAE,eAAe,KAAK,CAAC;AAAA,IACtE,QAAQ;AAEN;AAAA,IACF;AAEA,eAAW,SAAS,SAAS;AAC3B,UAAI,CAAC,MAAM,YAAY,EAAG;AAG1B,UACE,OAAO,MAAM,mBAAmB,cAChC,MAAM,eAAe,GACrB;AACA;AAAA,MACF;AAEA,YAAM,WAAW,KAAK,KAAK,SAAS,MAAM,IAAI;AAE9C,UAAI,MAAM,SAAS,gBAAgB;AACjC,gBAAQ,KAAK,QAAQ;AAErB;AAAA,MACF;AAEA,YAAM,KAAK,QAAQ;AAAA,IACrB;AAAA,EACF;AAEA,QAAM,KAAK,OAAO;AAClB,SAAO;AACT;AAKA,eAAsB,UAAU,KAA4B;AAC1D,QAAM,GAAG,SAAS,GAAG,KAAK,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC;AAC5D;AAUA,eAAsB,kBACpB,SACkC;AAClC,QAAM,UAAU,KAAK,QAAQ,OAAO;AACpC,QAAM,QAAQ,MAAM,oBAAoB,OAAO;AAE/C,QAAM,UAAoB,CAAC;AAE3B,aAAW,OAAO,OAAO;AACvB,QAAI;AACF,YAAM,UAAU,GAAG;AACnB,cAAQ,IAAI,eAAe,GAAG;AAC9B,cAAQ,KAAK,GAAG;AAAA,IAClB,SAAS,KAAU;AACjB,cAAQ,MAAM,oBAAoB,GAAG,KAAK,KAAK,WAAW,GAAG;AAAA,IAC/D;AAAA,EACF;AAEA,SAAO,EAAE,OAAO,QAAQ;AAC1B;AAAA,CAEC,iBAAkB;AACjB,QAAM,SAAS,QAAQ,KAAK,CAAC,KAAK,QAAQ,IAAI;AAC9C,MAAI,CAAC,GAAG,WAAW,MAAM,GAAG;AAC1B,YAAQ,IAAI,uBAAuB;AACnC;AAAA,EACF;AACA,QAAM,kBAAkB,MAAM;AAChC,GAAG;","names":[]}